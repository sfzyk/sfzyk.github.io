---
layout: post
title: 'Note:leetcode'
date: 2020-9-14
author: sf
color: rgb(255,210,32)
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: leetcode
---


## 1585. 检查字符串是否可以通过排序子字符串得到另一个字符串 ##
给你两个字符串 s 和 t ，请你通过若干次以下操作将字符串 s 转化成字符串 t ：
选择 s 中一个 非空 子字符串并将它包含的字符就地 升序 排序。
比方说，对下划线所示的子字符串进行操作可以由 "14234" 得到 "12344" 。
如果可以将字符串 s 变成 t ，返回 true 。否则，返回 false 。
一个 子字符串 定义为一个字符串中连续的若干字符。

示例 1：

输入：s = "84532", t = "34852"
输出：true
解释：你可以按以下操作将 s 转变为 t ：
"84532" （从下标 2 到下标 3）-> "84352"
"84352" （从下标 0 到下标 2） -> "34852"

示例 2：

输入：s = "34521", t = "23415"
输出：true
解释：你可以按以下操作将 s 转变为 t ：
"34521" -> "23451"
"23451" -> "23415"

示例 3：

输入：s = "12345", t = "12435"
输出：false

示例 4：

输入：s = "1", t = "2"
输出：false
提示：
    s.length == t.length
    1 <= s.length <= 105
    s 和 t 都只包含数字字符，即 '0' 到 '9' 。 
https://leetcode-cn.com/problems/check-if-string-is-transformable-with-substring-sort-operations

要注意到这里的下标正序排序可以等价位 相邻两位较大的数右移 而我们知道通过这种变换可以得到完全的升序排列
可以想到 在完全完全反序和 完全升序的所有状态中， 每个状态是有严格的先后关系的 ， 虽然看起来维度很高， 但毕竟是偏序的， 可判断一个序列和另外一个的偏序关系

我们考虑 t[0] 可以发现，我们可以
1  假设t[0] 在s中的所有出现是 最前面的那个移动到了 0这个位置上
2  只要t[0] 在s中的那个出现 前面没有更小的数 ，就一定可以做到，(优先移动t[0])
3  以此类推，t[1] 可以在视为忽视t0的存在 然后进行相同的操作
算法：
首先记录所有数字的出现位置
然后扫描， 对于 ti 来说只要 ti 在si 中的出现 之前没有比ti更小的没有归位的就可以， 

## 1584. 连接所有点的最小费用 ##
给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。

连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。

请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/min-cost-to-connect-all-points
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

最小生成树的板子题，但我没做出来 数据规模中点是1000   kruskal/Prim 算法都是 Elogv 我以为会超时，结果没有
kruskal，算法从最小边开始逐步添加 直到所有的点都已链接， 主要开销是 对边进行排序ElogE 就出去了
prim，加点法，每加一个点就添加所有相邻的点按照大小排序.

## 1583. 统计不开心的朋友 ##
给你一份 n 位朋友的亲近程度列表，其中 n 总是 偶数 。

对每位朋友 i，preferences[i] 包含一份 按亲近程度从高到低排列 的朋友列表。换句话说，排在列表前面的朋友与 i 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 0 到 n-1 之间的整数表示。

所有的朋友被分成几对，配对情况以列表 pairs 给出，其中 pairs[i] = [xi, yi] 表示 xi 与 yi 配对，且 yi 与 xi 配对。

但是，这样的配对情况可能会是其中部分朋友感到不开心。在 x 与 y 配对且 u 与 v 配对的情况下，如果同时满足下述两个条件，x 就会不开心：

    x 与 u 的亲近程度胜过 x 与 y，且
    u 与 x 的亲近程度胜过 u 与 v

返回 不开心的朋友的数目 。
 
 

简单的模拟即可，用map做 对于每一个人来说 找到可能产生不开心的人， 在可能那些不开心的人中找如果也找到了 就+1 

## 94. 二叉树的中序遍历 ##
1 递归算法比较简单，不赘述
2 迭代算法：使用栈模拟
    一直向左直到尽头 （途中入栈）
    弹出一个
    记录结果
    转向弹出这个的右孩子 重复上面的顺序
3 morris 算法重要的是降低空间复杂度为O1

predesend 是左孩子的最右孩子

如果有左孩子 那一定有P
